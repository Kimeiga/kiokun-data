<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiokun Dictionary</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .character {
            font-size: 96px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
            font-family: 'SimSun', 'MS Mincho', serif;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-hsk { background: #3498db; color: white; }
        .badge-jlpt { background: #e74c3c; color: white; }
        .badge-grade { background: #9b59b6; color: white; }
        .badge-freq { background: #27ae60; color: white; }
        .badge-stroke { background: #f39c12; color: white; }

        /* Section Styles */
        .section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            overflow: hidden;
        }

        .section-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            font-size: 24px;
            font-weight: bold;
        }

        .section-header.chinese {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        .section-header.japanese {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .section-content {
            padding: 30px;
        }

        .subsection {
            margin-bottom: 30px;
        }

        .subsection:last-child {
            margin-bottom: 0;
        }

        .subsection-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        /* Data Display */
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .data-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #3498db;
        }

        .data-item.japanese {
            border-left-color: #e74c3c;
        }

        .data-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .data-value {
            font-size: 16px;
            color: #2c3e50;
            font-weight: 500;
        }

        .data-value.large {
            font-size: 20px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        /* Word Entries */
        .word-entry {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .word-entry:hover {
            border-color: #3498db;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .word-reading {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }

        .word-definitions {
            margin: 10px 0;
        }

        .definition-item {
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .definition-item:last-child {
            border-bottom: none;
        }

        .definition-text {
            color: #495057;
            line-height: 1.5;
        }

        .pos-tag {
            display: inline-block;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #6c757d;
            margin-right: 8px;
            text-transform: uppercase;
        }

        /* Character Components */
        .components-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .component-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 24px;
            font-family: 'SimSun', 'MS Mincho', serif;
        }

        .component-item.meaning {
            border-color: #3498db;
        }

        .component-item.phonetic {
            border-color: #e74c3c;
        }

        /* IDS Display */
        .ids-display {
            font-size: 48px;
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'SimSun', 'MS Mincho', serif;
        }

        /* Etymology */
        .etymology-box {
            background: #fff9e6;
            border-left: 4px solid #f39c12;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 15px 0;
            font-style: italic;
            line-height: 1.8;
        }

        /* Statistics */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
        }



        /* Readings Display */
        .readings-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }

        .reading-chip {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            padding: 8px 15px;
            border-radius: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
        }

        .reading-chip.pinyin {
            border-color: #3498db;
            color: #3498db;
        }

        .reading-chip.onyomi {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .reading-chip.kunyomi {
            border-color: #9b59b6;
            color: #9b59b6;
        }

        .reading-chip.nanori {
            border-color: #27ae60;
            color: #27ae60;
        }

        /* Utility */
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #7f8c8d;
        }

        .error {
            text-align: center;
            padding: 50px;
            color: #e74c3c;
            background: #fdf2f2;
            border-radius: 12px;
            margin: 20px 0;
        }

        .search-box {
            width: 100%;
            max-width: 400px;
            padding: 15px 25px;
            border: 2px solid #e9ecef;
            border-radius: 30px;
            font-size: 18px;
            margin: 0 auto;
            display: block;
            text-align: center;
            font-family: 'SimSun', 'MS Mincho', serif;
        }

        .search-box:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            font-style: italic;
        }

        .list-item {
            padding: 8px 0;
            line-height: 1.6;
        }

        .list-item::before {
            content: "‚Ä¢ ";
            color: #3498db;
            font-weight: bold;
            margin-right: 8px;
        }

        @media (max-width: 768px) {
            .character { font-size: 64px; }
            .container { padding: 10px; }
            .data-grid { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .section-content { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 style="margin-bottom: 20px; color: #2c3e50;">üìö Kiokun Dictionary</h1>
            <input type="text" class="search-box" placeholder="Enter a character or word (e.g., Â•Ω, Âú∞Âõ≥)" id="searchBox">
        </div>

        <div id="content">
            <div class="loading">
                <p>Enter a character or word above to explore its meanings</p>
                <p style="margin-top: 10px; font-size: 14px; opacity: 0.7;">Try: Â•Ω, ÁöÑ, Âíå, Á©∫, Âú∞Âõ≥</p>
            </div>
        </div>
    </div>

    <script>
        class KiokunApp {
            constructor() {
                this.currentWord = null;
                this.setupEventListeners();
                this.loadFromURL();
            }

            setupEventListeners() {
                const searchBox = document.getElementById('searchBox');
                searchBox.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const word = e.target.value.trim();
                        if (word) {
                            this.loadWord(word);
                        }
                    }
                });

                window.addEventListener('popstate', (e) => {
                    if (e.state && e.state.word) {
                        this.loadWord(e.state.word, false);
                    } else {
                        this.loadFromURL();
                    }
                });
            }

            loadFromURL() {
                const path = window.location.pathname;
                if (path !== '/') {
                    const word = decodeURIComponent(path.substring(1));
                    if (word) {
                        document.getElementById('searchBox').value = word;
                        this.loadWord(word, false);
                    }
                }
            }

            async loadWord(word, updateURL = true) {
                const content = document.getElementById('content');
                content.innerHTML = '<div class="loading">Loading...</div>';

                try {
                    const response = await fetch(`../output_dictionary/${word}.json`);
                    if (!response.ok) {
                        throw new Error(`"${word}" not found`);
                    }

                    const data = await response.json();
                    this.currentWord = word;
                    this.renderData(data);

                    if (updateURL) {
                        window.history.pushState({word}, '', `/${word}`);
                    }
                } catch (error) {
                    content.innerHTML = `
                        <div class="error">
                            <h2>‚ùå Not Found</h2>
                            <p>${error.message}</p>
                            <p>Try: Â•Ω, ÁöÑ, Âíå, Á©∫</p>
                        </div>
                    `;
                }
            }

            async renderData(data) {
                const content = document.getElementById('content');
                const key = data.key || this.currentWord;

                // Store current data for access in other methods
                this.currentData = data;

                let html = `
                    <div class="header" style="margin-bottom: 30px;">
                        <div class="character">${key}</div>
                        ${this.renderBadges(data)}
                    </div>
                `;

                // Unified Character Section (if either Chinese or Japanese character data exists)
                if (data.chinese_char || data.japanese_char) {
                    html += this.renderUnifiedCharacter(data.chinese_char, data.japanese_char, key);
                }

                // Chinese Words
                if (data.chinese_words && data.chinese_words.length > 0) {
                    html += this.renderChineseWords(data.chinese_words);
                }

                content.innerHTML = html;

                // Collect all Japanese words (direct + related)
                const allJapaneseWords = [];

                // Add direct Japanese words
                if (data.japanese_words && data.japanese_words.length > 0) {
                    data.japanese_words.forEach(word => {
                        allJapaneseWords.push({ word, isDirect: true });
                    });
                }

                // Fetch and add related Japanese words
                if (data.related_japanese_words && data.related_japanese_words.length > 0) {
                    for (const relatedKey of data.related_japanese_words) {
                        try {
                            const response = await fetch(`../output_dictionary/${relatedKey}.json`);
                            if (response.ok) {
                                const relatedData = await response.json();
                                if (relatedData.japanese_words && relatedData.japanese_words.length > 0) {
                                    relatedData.japanese_words.forEach(word => {
                                        allJapaneseWords.push({ word, isDirect: false, sourceKey: relatedKey });
                                    });
                                }
                            }
                        } catch (error) {
                            console.error(`Failed to fetch related word: ${relatedKey}`, error);
                        }
                    }
                }

                // Render all Japanese words together
                if (allJapaneseWords.length > 0) {
                    const japaneseHtml = this.renderJapaneseWords(allJapaneseWords, key);
                    content.innerHTML += japaneseHtml;
                }
            }

            renderBadges(data) {
                const badges = [];

                // Chinese character stats
                if (data.chinese_char?.statistics?.hskLevel) {
                    badges.push(`<span class="badge badge-hsk">HSK ${data.chinese_char.statistics.hskLevel}</span>`);
                }

                // Japanese character stats
                if (data.japanese_char?.misc?.grade) {
                    badges.push(`<span class="badge badge-grade">Grade ${data.japanese_char.misc.grade}</span>`);
                }

                if (data.japanese_char?.misc?.jlptLevel) {
                    badges.push(`<span class="badge badge-jlpt">JLPT N${data.japanese_char.misc.jlptLevel}</span>`);
                }

                if (data.japanese_char?.misc?.frequency) {
                    badges.push(`<span class="badge badge-freq">Freq: ${data.japanese_char.misc.frequency}</span>`);
                }

                if (data.chinese_char?.strokeCount) {
                    badges.push(`<span class="badge badge-stroke">${data.chinese_char.strokeCount} strokes</span>`);
                }

                return badges.length > 0 ? `<div class="badges">${badges.join('')}</div>` : '';
            }

            renderUnifiedCharacter(chineseChar, japaneseChar, key) {
                let html = `
                    <div class="section">
                        <div class="section-header" style="background: linear-gradient(135deg, #3498db 0%, #e74c3c 100%);">
                            üìù Character
                        </div>
                        <div class="section-content">
                `;

                // Get HSK level from chinese_words if not in character
                let hskLevel = chineseChar?.hskLevel;
                if (!hskLevel && this.currentData?.chinese_words?.[0]?.statistics?.hskLevel) {
                    hskLevel = this.currentData.chinese_words[0].statistics.hskLevel;
                }

                // Character and gloss header (larger character, gloss left-aligned)
                html += `<div style="margin-bottom: 20px;">`;
                html += `<div style="display: flex; align-items: center; gap: 20px; margin-bottom: 10px;">`;

                // Large character (72px)
                html += `<div style="font-size: 72px; font-weight: bold; font-family: 'MS Mincho', serif; line-height: 1;">${key}</div>`;

                // Gloss (left-aligned after character)
                if (chineseChar?.gloss) {
                    html += `<div style="font-size: 24px; color: #27ae60; font-weight: 600;">${chineseChar.gloss}</div>`;
                }

                html += `</div>`;

                // Flags below character
                html += `<div style="font-size: 12px; color: #7f8c8d; margin-bottom: 10px;">`;
                if (japaneseChar) html += `üáØüáµ `;
                if (chineseChar) html += `üá®üá≥ üáπüáº`;
                html += `</div>`;

                // Mnemonic hint right after character
                if (chineseChar?.hint) {
                    html += `<div style="margin-top: 12px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">`;
                    html += `<div style="font-size: 13px; color: #856404; line-height: 1.6;">üí° ${chineseChar.hint}</div>`;
                    html += `</div>`;
                }

                html += `</div>`;

                // COMPONENTS (moved up before pronunciations)
                if (chineseChar?.components && chineseChar.components.length > 0) {
                    html += `<div style="margin-bottom: 20px;">`;
                    html += `<div style="font-weight: 600; font-size: 16px; margin-bottom: 12px; color: #2c3e50;">ÔøΩ Components</div>`;
                    html += `<div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-start;">`;

                    // Get stroke data
                    const makeHanziData = chineseChar.images?.find(img => img.source === 'makemeahanzi');
                    const strokes = makeHanziData?.data?.strokes || [];

                    // Simple heuristic for component stroke mapping
                    const getComponentStrokeRanges = (numStrokes, numComponents) => {
                        if (numComponents === 2) {
                            const mid = Math.floor(numStrokes / 2);
                            return [[0, mid], [mid, numStrokes]];
                        }
                        const strokesPerComponent = Math.floor(numStrokes / numComponents);
                        return Array.from({length: numComponents}, (_, i) => {
                            const start = i * strokesPerComponent;
                            const end = i === numComponents - 1 ? numStrokes : (i + 1) * strokesPerComponent;
                            return [start, end];
                        });
                    };

                    const strokeRanges = strokes.length > 0 ? getComponentStrokeRanges(strokes.length, chineseChar.components.length) : [];

                    // Component cards with highlighted strokes
                    chineseChar.components.forEach((comp, compIdx) => {
                        const char = typeof comp === 'string' ? comp : (comp.character || comp.char || comp);
                        const types = comp.type || [];
                        const isMeaning = types.includes('meaning');
                        const isPhonetic = types.includes('phonetic');
                        const highlightColor = isMeaning ? '#27ae60' : isPhonetic ? '#e74c3c' : '#95a5a6';

                        html += `<div style="text-align: center; padding: 8px; background: white; border-radius: 6px; border: 2px solid ${highlightColor};">`;

                        // Show character with highlighted component strokes
                        if (strokes.length > 0 && strokeRanges[compIdx]) {
                            const [startStroke, endStroke] = strokeRanges[compIdx];
                            html += `<svg viewBox="0 0 1024 1024" width="80" height="80" style="display: block; margin: 0 auto;">`;
                            html += `<g transform="scale(1, -1) translate(0, -900)">`;
                            strokes.forEach((stroke, idx) => {
                                const isHighlighted = idx >= startStroke && idx < endStroke;
                                const fillColor = isHighlighted ? highlightColor : '#e8e8e8';
                                html += `<path d="${stroke}" fill="${fillColor}" stroke="none"/>`;
                            });
                            html += `</g></svg>`;
                        } else {
                            html += `<div style="font-size: 32px; font-family: 'MS Mincho', serif; line-height: 1;">${char}</div>`;
                        }

                        // Component info
                        html += `<div style="font-size: 16px; font-weight: 600; margin-top: 6px; font-family: 'MS Mincho', serif;">${char}</div>`;
                        if (types.length > 0) {
                            html += `<div style="font-size: 10px; color: ${highlightColor}; margin-top: 4px; font-weight: 600;">`;
                            html += types.map(t => t === 'meaning' ? 'üü¢ meaning' : t === 'phonetic' ? 'üî¥ sound' : t).join(' ');
                            html += `</div>`;
                        }
                        html += `</div>`;
                    });

                    html += `</div></div>`;
                }

                // PRONUNCIATIONS (simplified - no header, just flags)
                html += `<div style="margin-bottom: 20px;">`;

                // Chinese Pinyin (simplified)
                if (chineseChar?.pinyinFrequencies && chineseChar.pinyinFrequencies.length > 0) {
                    html += `<div style="margin-bottom: 8px;">`;
                    html += `<span style="font-size: 14px;">üá®üá≥</span> `;
                    html += `<span style="font-size: 18px; color: #3498db; font-weight: 600;">`;
                    html += chineseChar.pinyinFrequencies.map(pf => pf.pinyin).join(', ');
                    html += `</span></div>`;
                }

                // Japanese Readings (simplified)
                if (japaneseChar?.readingMeaning?.groups) {
                    const group = japaneseChar.readingMeaning.groups[0];
                    const onyomi = group?.readings?.filter(r => r.type === 'ja_on').map(r => r.value) || [];
                    const kunyomi = group?.readings?.filter(r => r.type === 'ja_kun').map(r => r.value) || [];
                    const nanori = group?.readings?.filter(r => r.type === 'ja_nanori').map(r => r.value) || [];

                    const formatReading = (reading) => {
                        const parts = reading.split('.');
                        if (parts.length === 1) return reading;
                        return parts.map((part, idx) => idx === 0 ? part : `<span style="color: #95a5a6;">${part}</span>`).join('.');
                    };

                    html += `<div style="margin-bottom: 8px;">`;
                    html += `<span style="font-size: 14px;">üáØüáµ</span> `;

                    if (onyomi.length > 0) {
                        html += `<span style="font-size: 18px; color: #e74c3c; font-family: 'MS Mincho', serif;">`;
                        html += onyomi.map(r => formatReading(r)).join('„ÄÅ');
                        html += `</span>`;
                    }

                    if (kunyomi.length > 0) {
                        if (onyomi.length > 0) html += ` <span style="color: #bdc3c7;">|</span> `;
                        html += `<span style="font-size: 18px; color: #27ae60; font-family: 'MS Mincho', serif;">`;
                        html += kunyomi.map(r => formatReading(r)).join('„ÄÅ');
                        html += `</span>`;
                    }

                    if (nanori.length > 0) {
                        html += `<div style="margin-top: 6px; margin-left: 24px;">`;
                        html += `<span style="font-size: 12px; color: #7f8c8d;">Names:</span> `;
                        html += `<span style="font-size: 14px; color: #9b59b6; font-family: 'MS Mincho', serif;">`;
                        html += nanori.map(r => formatReading(r)).join('„ÄÅ');
                        html += `</span></div>`;
                    }

                    html += `</div>`;
                }

                html += `</div>`;

                // MEANINGS (simplified - no header)
                html += `<div style="margin-bottom: 20px;">`;

                // Chinese meaning (use gloss if meaning is not available)
                const chineseMeaning = chineseChar?.meaning || chineseChar?.gloss;
                if (chineseMeaning) {
                    html += `<div style="margin-bottom: 8px; line-height: 1.6;">`;
                    html += `<span style="font-size: 14px;">üá®üá≥</span> `;
                    html += `<span style="color: #2c3e50;">${chineseMeaning}</span>`;
                    html += `</div>`;
                }

                // Japanese meanings
                if (japaneseChar?.readingMeaning?.groups?.[0]?.meanings) {
                    const meanings = japaneseChar.readingMeaning.groups[0].meanings.map(m =>
                        typeof m === 'string' ? m : (m.value || m.text || m)
                    ).join(', ');
                    html += `<div style="margin-bottom: 8px; line-height: 1.6;">`;
                    html += `<span style="font-size: 14px;">üáØüáµ</span> `;
                    html += `<span style="color: #2c3e50;">${meanings}</span>`;
                    html += `</div>`;
                }

                html += `</div>`;

                // SHUOWEN (Etymology - only if available)
                if (chineseChar?.shuowen) {
                    html += `<div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">`;
                    html += `<div style="font-weight: 600; font-size: 16px; margin-bottom: 8px; color: #2c3e50;">üìú Ë™™ÊñáËß£Â≠ó (Shuowen Jiezi)</div>`;
                    html += `<div style="font-size: 14px; color: #2c3e50; line-height: 1.6;">${chineseChar.shuowen}</div>`;
                    html += `</div>`;
                }

                // STATISTICS
                html += `<div style="margin-bottom: 20px;">`;
                html += `<div style="font-weight: 600; font-size: 16px; margin-bottom: 12px; color: #2c3e50;">üìä Statistics</div>`;
                html += `<div style="display: flex; flex-wrap: wrap; gap: 15px;">`;

                // Chinese stats
                if (chineseChar) {
                    html += `<div style="flex: 1; min-width: 200px;">`;
                    html += `<div style="font-size: 13px; color: #7f8c8d; margin-bottom: 8px;">üá®üá≥ Chinese</div>`;
                    html += `<div style="display: flex; flex-wrap: wrap; gap: 8px;">`;

                    if (hskLevel) {
                        html += `<span class="badge badge-hsk">HSK ${hskLevel}</span>`;
                    }
                    if (chineseChar.strokeCount) {
                        html += `<span class="badge" style="background: #e3f2fd; color: #1976d2;">‚úèÔ∏è ${chineseChar.strokeCount} strokes</span>`;
                    }

                    html += `</div></div>`;
                }

                // Japanese stats
                if (japaneseChar?.misc) {
                    html += `<div style="flex: 1; min-width: 200px;">`;
                    html += `<div style="font-size: 13px; color: #7f8c8d; margin-bottom: 8px;">üáØüáµ Japanese</div>`;
                    html += `<div style="display: flex; flex-wrap: wrap; gap: 8px;">`;

                    if (japaneseChar.misc.grade) {
                        html += `<span class="badge" style="background: #f3e5f5; color: #7b1fa2;">üéì Grade ${japaneseChar.misc.grade}</span>`;
                    }
                    if (japaneseChar.misc.jlptLevel) {
                        html += `<span class="badge" style="background: #fff3cd; color: #856404;">JLPT N${japaneseChar.misc.jlptLevel}</span>`;
                    }
                    if (japaneseChar.misc.frequency) {
                        html += `<span class="badge" style="background: #fce4ec; color: #c2185b;">üìä Freq. ${japaneseChar.misc.frequency.toLocaleString()}</span>`;
                    }
                    if (japaneseChar.misc.strokeCounts && japaneseChar.misc.strokeCounts.length > 0) {
                        html += `<span class="badge" style="background: #e3f2fd; color: #1976d2;">‚úèÔ∏è ${japaneseChar.misc.strokeCounts[0]} strokes</span>`;
                    }

                    html += `</div></div>`;
                }

                html += `</div></div>`;

                // HISTORICAL EVOLUTION (Images)
                if (chineseChar?.images && chineseChar.images.length > 0) {
                    html += `<div style="margin-bottom: 20px;">`;
                    html += `<div style="font-weight: 600; font-size: 16px; margin-bottom: 12px; color: #2c3e50;">üèõÔ∏è Historical Evolution</div>`;
                    html += `<div style="display: flex; gap: 12px; overflow-x: auto; padding: 10px 0;">`;

                    // Group images by type
                    const imagesByType = {};
                    chineseChar.images.forEach(img => {
                        if (!imagesByType[img.type]) imagesByType[img.type] = [];
                        imagesByType[img.type].push(img);
                    });

                    // Display in chronological order
                    const typeOrder = ['Oracle', 'Bronze', 'Seal', 'Clerical', 'Regular'];
                    typeOrder.forEach(type => {
                        if (imagesByType[type]) {
                            // Show first image of each type
                            const img = imagesByType[type][0];
                            if (img.url) {
                                html += `<div style="flex-shrink: 0; text-align: center; padding: 10px; background: white; border-radius: 8px; border: 1px solid #e0e0e0;">`;
                                html += `<img src="${img.url}" style="width: 80px; height: 80px; object-fit: contain;" alt="${img.type}" onerror="this.style.display='none'">`;
                                html += `<div style="font-size: 11px; color: #7f8c8d; margin-top: 6px; font-weight: 600;">${img.type}</div>`;
                                html += `<div style="font-size: 10px; color: #95a5a6; margin-top: 2px;">${img.era || ''}</div>`;
                                html += `</div>`;
                            } else if (img.data) {
                                // Make Me a Hanzi data - we could render SVG here
                                html += `<div style="flex-shrink: 0; text-align: center; padding: 10px; background: white; border-radius: 8px; border: 1px solid #e0e0e0;">`;
                                html += `<div style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; font-size: 48px; font-family: 'MS Mincho', serif;">${key}</div>`;
                                html += `<div style="font-size: 11px; color: #7f8c8d; margin-top: 6px; font-weight: 600;">${img.type}</div>`;
                                html += `<div style="font-size: 10px; color: #95a5a6; margin-top: 2px;">${img.era || ''}</div>`;
                                html += `</div>`;
                            }
                        }
                    });

                    html += `</div></div>`;
                }

                // ADDITIONAL INFO (Historical pronunciations, variants, radicals)
                const hasAdditionalInfo = (chineseChar?.oldPronunciations && chineseChar.oldPronunciations.length > 0) ||
                                         (chineseChar?.variants && chineseChar.variants.length > 0) ||
                                         (japaneseChar?.radicals && japaneseChar.radicals.length > 0);

                if (hasAdditionalInfo) {
                    html += `<div style="padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 13px; color: #555;">`;

                    // Historical pronunciations
                    if (chineseChar?.oldPronunciations && chineseChar.oldPronunciations.length > 0) {
                        html += `<div style="margin-bottom: 10px;">`;
                        html += `<div style="font-weight: 600; margin-bottom: 6px;">Historical Pronunciations</div>`;
                        chineseChar.oldPronunciations.forEach(op => {
                            html += `<div style="margin-left: 10px; margin-bottom: 4px;">`;
                            html += `<span style="font-weight: 600;">${op.pinyin}</span> - ${op.gloss || 'no gloss'}<br>`;
                            if (op.middleChinese) html += `<span style="color: #7f8c8d;">Middle Chinese: ${op.middleChinese}</span><br>`;
                            if (op.oldChinese) html += `<span style="color: #7f8c8d;">Old Chinese: ${op.oldChinese}</span>`;
                            html += `</div>`;
                        });
                        html += `</div>`;
                    }

                    // Variants
                    if (chineseChar?.variants && chineseChar.variants.length > 0) {
                        html += `<div style="margin-bottom: 10px;">`;
                        html += `<span style="font-weight: 600;">Variants:</span> `;
                        html += `<span style="font-size: 18px; font-family: 'MS Mincho', serif;">`;
                        // Handle both string and object formats
                        const variantChars = chineseChar.variants.map(v =>
                            typeof v === 'string' ? v : (v.char || v.character || v)
                        );
                        html += variantChars.join(', ');
                        html += `</span></div>`;
                    }

                    // Radicals
                    if (japaneseChar?.radicals && japaneseChar.radicals.length > 0) {
                        html += `<div>`;
                        html += `<span style="font-weight: 600;">Radicals:</span> `;
                        html += japaneseChar.radicals.map(rad => `${rad.type}: ${rad.value}`).join(', ');
                        html += `</div>`;
                    }

                    html += `</div>`;
                }

                html += `</div></div>`;
                return html;
            }

            renderChineseChar(char) {
                let html = `
                    <div class="section">
                        <div class="section-header chinese">üá®üá≥ Chinese Character</div>
                        <div class="section-content">
                `;

                // Pinyin readings
                if (char.pinyinFrequencies && char.pinyinFrequencies.length > 0) {
                    html += `<div class="subsection">
                        <div class="subsection-title">Pinyin Readings</div>
                        <div class="readings-list">`;
                    char.pinyinFrequencies.forEach(item => {
                        html += `<span class="reading-chip pinyin">${item.pinyin}</span>`;
                    });
                    html += `</div></div>`;
                }

                // Gloss
                if (char.gloss) {
                    html += `<div class="subsection">
                        <div class="subsection-title">Meaning</div>
                        <div class="data-value large">${char.gloss}</div>
                    </div>`;
                }

                // Etymology (Shuowen)
                if (char.shuowen) {
                    html += `<div class="subsection">
                        <div class="subsection-title">Etymology (Ë™™ÊñáËß£Â≠ó)</div>
                        <div class="etymology-box">${char.shuowen}</div>
                    </div>`;
                }

                // Components
                if (char.components && char.components.length > 0) {
                    html += `<div class="subsection">
                        <div class="subsection-title">Components</div>
                        <div class="components-list">`;
                    char.components.forEach(comp => {
                        const typeClass = comp.type.includes('meaning') ? 'meaning' : 'phonetic';
                        html += `<div class="component-item ${typeClass}" title="${comp.type.join(', ')}">${comp.character}</div>`;
                    });
                    html += `</div></div>`;
                }

                // Old Pronunciations (Middle Chinese, Old Chinese)
                if (char.oldPronunciations && char.oldPronunciations.length > 0) {
                    html += `<div class="subsection">
                        <div class="subsection-title">Historical Pronunciations</div>`;
                    char.oldPronunciations.forEach(old => {
                        html += `<div style="margin-bottom: 10px; padding: 12px; background: #fff9e6; border-left: 3px solid #f39c12; border-radius: 0 6px 6px 0;">`;
                        html += `<div style="font-weight: bold; margin-bottom: 5px;">${old.pinyin} - ${old.gloss}</div>`;
                        if (old.MC) html += `<div style="font-size: 14px; color: #7f8c8d;">Middle Chinese: <span style="font-family: monospace; color: #2c3e50;">${old.MC}</span></div>`;
                        if (old.OC) html += `<div style="font-size: 14px; color: #7f8c8d;">Old Chinese: <span style="font-family: monospace; color: #2c3e50;">${old.OC}</span></div>`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                }

                // Variants
                if (char.variants && char.variants.length > 0) {
                    html += `<div class="subsection">
                        <div class="subsection-title">Variants</div>
                        <div class="components-list">`;
                    char.variants.forEach(variant => {
                        if (variant.char) {
                            html += `<div class="component-item" title="${variant.parts || ''}">${variant.char}</div>`;
                        }
                    });
                    html += `</div></div>`;
                }

                // Statistics
                if (char.statistics) {
                    html += `<div class="subsection">
                        <div class="subsection-title">Statistics</div>
                        <div class="stats-grid">`;
                    if (char.statistics.hskLevel) {
                        html += `<div class="stat-item">
                            <div class="stat-value">${char.statistics.hskLevel}</div>
                            <div class="stat-label">HSK Level</div>
                        </div>`;
                    }
                    if (char.strokeCount) {
                        html += `<div class="stat-item">
                            <div class="stat-value">${char.strokeCount}</div>
                            <div class="stat-label">Strokes</div>
                        </div>`;
                    }
                    html += `</div></div>`;
                }

                html += `</div></div>`;
                return html;
            }

            renderJapaneseChar(char) {
                let html = `
                    <div class="section">
                        <div class="section-header japanese">üáØüáµ Japanese Character</div>
                        <div class="section-content">
                `;

                // Compact readings and meanings layout
                if (char.readingMeaning?.groups) {
                    const group = char.readingMeaning.groups[0];

                    // Collect readings
                    const onyomi = group?.readings?.filter(r => r.type === 'ja_on').map(r => r.value) || [];
                    const kunyomi = group?.readings?.filter(r => r.type === 'ja_kun').map(r => r.value) || [];
                    const nanori = group?.readings?.filter(r => r.type === 'ja_nanori').map(r => r.value) || [];

                    // Helper function to format readings with color-coded okurigana
                    const formatReading = (reading) => {
                        // Split on dots to separate kanji reading from okurigana
                        const parts = reading.split('.');
                        if (parts.length === 1) {
                            // No okurigana, just return the reading
                            return reading;
                        }
                        // Color the okurigana parts
                        return parts.map((part, idx) => {
                            if (idx === 0) return part; // First part is the kanji reading
                            return `<span style="color: #95a5a6;">${part}</span>`; // Okurigana in gray
                        }).join('.');
                    };

                    // On'yomi readings (katakana)
                    if (onyomi.length > 0) {
                        html += `<div style="margin-bottom: 12px; line-height: 1.8;">`;
                        html += `<span style="font-size: 20px; color: #e74c3c; font-family: 'MS Mincho', serif;">`;
                        html += onyomi.map(r => formatReading(r)).join('„ÄÅ');
                        html += `</span>`;
                        html += `</div>`;
                    }

                    // Kun'yomi readings (hiragana with okurigana)
                    if (kunyomi.length > 0) {
                        html += `<div style="margin-bottom: 12px; line-height: 1.8;">`;
                        html += `<span style="font-size: 18px; color: #27ae60; font-family: 'MS Mincho', serif;">`;
                        html += kunyomi.map(r => formatReading(r)).join('„ÄÅ');
                        html += `</span>`;
                        html += `</div>`;
                    }

                    // Nanori readings (name readings)
                    if (nanori.length > 0) {
                        html += `<div style="margin-bottom: 12px; line-height: 1.8;">`;
                        html += `<span style="font-size: 14px; color: #7f8c8d;">Names (Âêç‰πó„Çä) </span>`;
                        html += `<span style="font-size: 16px; color: #9b59b6; font-family: 'MS Mincho', serif;">`;
                        html += nanori.map(r => formatReading(r)).join('„ÄÅ');
                        html += `</span>`;
                        html += `</div>`;
                    }

                    // Meanings on one line
                    if (group?.meanings && group.meanings.length > 0) {
                        const meanings = group.meanings.map(m =>
                            typeof m === 'string' ? m : (m.value || m.text || m)
                        ).join(', ');
                        html += `<div style="margin-bottom: 15px; font-size: 16px; color: #2c3e50; line-height: 1.6;">${meanings}</div>`;
                    }
                }

                // Compact stats line
                html += `<div style="display: flex; gap: 20px; align-items: center; padding: 12px 0; border-top: 1px solid #e9ecef; font-size: 14px; color: #7f8c8d;">`;

                if (char.misc?.strokeCounts && char.misc.strokeCounts.length > 0) {
                    html += `<span>‚úèÔ∏è ${char.misc.strokeCounts[0]} strokes</span>`;
                }

                if (char.misc?.frequency) {
                    html += `<span>üìä Freq. ${char.misc.frequency.toLocaleString()} / 2,500</span>`;
                }

                if (char.misc?.grade) {
                    html += `<span>üéì Grade ${char.misc.grade}</span>`;
                }

                if (char.misc?.jlptLevel) {
                    html += `<span class="badge" style="background: #fff3cd; color: #856404;">JLPT ${char.misc.jlptLevel}</span>`;
                }

                html += `</div>`;

                // Radicals (if present)
                if (char.radicals && char.radicals.length > 0) {
                    html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e9ecef; font-size: 13px; color: #7f8c8d;">`;
                    html += `<span style="font-weight: 600;">Radicals:</span> `;
                    html += char.radicals.map(rad => `${rad.type}: ${rad.value}`).join(', ');
                    html += `</div>`;
                }

                html += `</div></div>`;
                return html;
            }

            renderChineseWords(words) {
                let html = `
                    <div class="section">
                        <div class="section-header chinese">üìñ Chinese Words</div>
                        <div class="section-content">
                `;

                words.forEach(word => {
                    html += `<div class="word-entry">`;

                    // Word header
                    html += `<div style="margin-bottom: 15px;">
                        <span style="font-size: 24px; font-weight: bold; font-family: 'SimSun', serif;">${word.simp}</span>`;
                    if (word.trad && word.trad !== word.simp) {
                        html += ` <span style="font-size: 20px; color: #7f8c8d;">(${word.trad})</span>`;
                    }
                    if (word.gloss) {
                        html += ` <span style="margin-left: 15px; color: #27ae60; font-weight: 600;">${word.gloss}</span>`;
                    }
                    html += `</div>`;

                    // Items (different pronunciations/definitions)
                    if (word.items && word.items.length > 0) {
                        // Filter out items without definitions
                        const itemsWithDefs = word.items.filter(item =>
                            item.definitions && item.definitions.length > 0
                        );

                        itemsWithDefs.forEach(item => {
                            html += `<div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">`;

                            if (item.pinyin) {
                                html += `<div class="word-reading">${item.pinyin}</div>`;
                            }

                            if (item.definitions && item.definitions.length > 0) {
                                // Join all definitions with semicolons on one line
                                const definitionsText = item.definitions.join('; ');
                                html += `<div class="definition-text" style="margin: 10px 0; line-height: 1.6;">${definitionsText}</div>`;
                            }

                            html += `</div>`;
                        });
                    }

                    // Statistics
                    if (word.statistics) {
                        html += this.renderChineseWordStatistics(word.statistics);
                    }

                    html += `</div>`;
                });

                html += `</div></div>`;
                return html;
            }



            renderChineseWordStatistics(stats) {
                let html = `<div style="margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px;">`;
                html += `<div style="font-weight: 600; font-size: 16px; margin-bottom: 15px; color: #2c3e50;">üìä Usage Statistics</div>`;

                // HSK Level and Frequency
                html += `<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">`;
                if (stats.hskLevel) {
                    html += `<span class="badge badge-hsk">HSK ${stats.hskLevel}</span>`;
                }
                if (stats.movieWordRank) {
                    html += `<span class="badge" style="background: #e3f2fd; color: #1976d2;">Movie Rank: #${stats.movieWordRank.toLocaleString()}</span>`;
                }
                if (stats.bookWordRank) {
                    html += `<span class="badge" style="background: #f3e5f5; color: #7b1fa2;">Book Rank: #${stats.bookWordRank.toLocaleString()}</span>`;
                }
                html += `</div>`;

                // Frequency bars
                if (stats.movieWordCountPercent || stats.bookWordCountPercent) {
                    html += `<div style="margin-bottom: 20px;">`;
                    html += `<div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #555;">Frequency</div>`;

                    if (stats.movieWordCountPercent) {
                        const moviePercent = (stats.movieWordCountPercent * 100).toFixed(4);
                        html += `<div style="margin-bottom: 8px;">`;
                        html += `<div style="display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px;">`;
                        html += `<span>Movies: ${stats.movieWordCount.toLocaleString()} occurrences</span>`;
                        html += `<span>${moviePercent}%</span>`;
                        html += `</div>`;
                        html += `<div style="background: #e0e0e0; height: 8px; border-radius: 4px; overflow: hidden;">`;
                        html += `<div style="background: linear-gradient(90deg, #1976d2, #42a5f5); height: 100%; width: ${Math.min(moviePercent * 10, 100)}%;"></div>`;
                        html += `</div></div>`;
                    }

                    if (stats.bookWordCountPercent) {
                        const bookPercent = (stats.bookWordCountPercent * 100).toFixed(4);
                        html += `<div style="margin-bottom: 8px;">`;
                        html += `<div style="display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 3px;">`;
                        html += `<span>Books: ${stats.bookWordCount.toLocaleString()} occurrences</span>`;
                        html += `<span>${bookPercent}%</span>`;
                        html += `</div>`;
                        html += `<div style="background: #e0e0e0; height: 8px; border-radius: 4px; overflow: hidden;">`;
                        html += `<div style="background: linear-gradient(90deg, #7b1fa2, #ba68c8); height: 100%; width: ${Math.min(bookPercent * 10, 100)}%;"></div>`;
                        html += `</div></div>`;
                    }

                    html += `</div>`;
                }

                // Top Words
                if (stats.topWords && stats.topWords.length > 0) {
                    html += `<div style="margin-top: 20px;">`;
                    html += `<div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #555;">Top Words Containing This Character</div>`;
                    html += `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px;">`;

                    // Show top 12 words
                    stats.topWords.slice(0, 12).forEach(topWord => {
                        const sharePercent = (topWord.share * 100).toFixed(1);
                        // Use share percentage as background width (light blue gradient)
                        html += `<div style="position: relative; padding: 8px 12px; background: white; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 13px; overflow: hidden;">`;
                        // Background progress bar
                        html += `<div style="position: absolute; top: 0; left: 0; height: 100%; width: ${topWord.share * 100}%; background: linear-gradient(90deg, #e3f2fd, #bbdefb); opacity: 0.6; z-index: 0;"></div>`;
                        // Content (relative positioned to appear above background)
                        html += `<div style="position: relative; z-index: 1;">`;
                        html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
                        html += `<span style="font-weight: 600; color: #2c3e50;">${topWord.word}</span>`;
                        html += `<span style="font-size: 11px; color: #1976d2; font-weight: 600;">${sharePercent}%</span>`;
                        html += `</div>`;
                        if (topWord.gloss) {
                            html += `<div style="font-size: 11px; color: #555; margin-top: 2px;">${topWord.gloss}</div>`;
                        }
                        html += `</div>`;
                        html += `</div>`;
                    });

                    html += `</div></div>`;
                }

                html += `</div>`;
                return html;
            }

            renderJapaneseWords(wordEntries, currentKey) {
                let html = `
                    <div class="section">
                        <div class="section-header japanese">üìñ Japanese Words</div>
                        <div class="section-content">
                `;

                wordEntries.forEach(({ word, isDirect, sourceKey }) => {
                    html += `<div class="word-entry">`;

                    // Kanji and Kana on one line
                    html += `<div style="margin-bottom: 8px; line-height: 1.8;">`;

                    // Show all kanji forms (comma separated)
                    if (word.kanji && word.kanji.length > 0) {
                        const kanjiTexts = word.kanji.map(k => {
                            // Bold the current character if it appears in the kanji
                            if (!isDirect && k.text.includes(currentKey)) {
                                return k.text.replace(new RegExp(currentKey, 'g'), `<strong>${currentKey}</strong>`);
                            }
                            return k.text;
                        }).join(', ');
                        html += `<span style="font-size: 20px; font-family: 'MS Mincho', serif;">${kanjiTexts}</span> `;
                    }

                    // Kana readings
                    if (word.kana && word.kana.length > 0) {
                        html += `<span style="font-size: 18px; color: #e74c3c; font-family: 'MS Mincho', serif;">[${word.kana.map(k => k.text).join(', ')}]</span>`;
                    }

                    html += `</div>`;

                    // Senses (meanings) - inline tags with definitions
                    if (word.sense && word.sense.length > 0) {
                        word.sense.forEach((sense, idx) => {
                            html += `<div style="margin-bottom: 10px; line-height: 1.8;">`;

                            // Part of speech tags inline
                            if (sense.partOfSpeech && sense.partOfSpeech.length > 0) {
                                sense.partOfSpeech.forEach(pos => {
                                    html += `<span class="pos-tag" style="display: inline; margin-right: 6px;">${pos}</span>`;
                                });
                            }

                            // Misc tags inline (like (uk) for usually kana)
                            if (sense.misc && sense.misc.length > 0) {
                                sense.misc.forEach(misc => {
                                    html += `<span class="pos-tag" style="display: inline; margin-right: 6px; background: #fff3cd; color: #856404;">${misc}</span>`;
                                });
                            }

                            // Glosses inline with tags
                            if (sense.gloss && sense.gloss.length > 0) {
                                const glossText = sense.gloss.map(g => g.text).join('; ');
                                html += `<span style="color: #2c3e50;">${glossText}</span>`;
                            }

                            html += `</div>`;
                        });
                    }

                    html += `</div>`;
                });

                html += `</div></div>`;
                return html;
            }
        }

        // Initialize the app
        const app = new KiokunApp();
    </script>
</body>
</html>
